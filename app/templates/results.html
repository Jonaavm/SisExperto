{% extends "layout.html" %}

{% block title %}Resultados - Sistema Experto{% endblock %}

{% block content %}
<div class="results-container">
    <div class="header-section">
        <h1>üìä Resultados del Modelo</h1>
        <p>An√°lisis completo del rendimiento y visualizaciones</p>
    </div>

    <!-- Selecci√≥n de Modelo para Resultados -->
    <div class="card">
        <div class="card-header">
            <h2>üîç Seleccionar Modelo para An√°lisis</h2>
        </div>
        <div class="card-body">
            <div class="model-selection">
                <select id="resultsModelSelect" class="form-select">
                    <option value="">Selecciona un modelo para ver resultados...</option>
                </select>
                <button id="refreshResultsModels" class="btn btn-secondary">
                    <i>üîÑ</i> Actualizar
                </button>
            </div>
        </div>
    </div>

    <!-- M√©tricas de Rendimiento -->
    <div class="card" id="metricsCard" style="display: none;">
        <div class="card-header">
            <h2>üìà M√©tricas de Rendimiento</h2>
        </div>
        <div class="card-body">
            <div class="metrics-grid" id="metricsGrid">
                <!-- Las m√©tricas se cargar√°n din√°micamente -->
            </div>
            
            <div class="metrics-table-container">
                <h3>üìã Reporte Detallado por Clase</h3>
                <div id="classificationReport" class="table-container">
                    <!-- Tabla de reporte de clasificaci√≥n -->
                </div>
            </div>
        </div>
    </div>

    <!-- Matriz de Confusi√≥n -->
    <div class="card" id="confusionCard" style="display: none;">
        <div class="card-header">
            <h2>üéØ Matriz de Confusi√≥n</h2>
        </div>
        <div class="card-body">
            <div class="confusion-matrix-container">
                <div id="confusionMatrixTable"></div>
            </div>
            <div id="confusionDetails" class="confusion-details">
                <!-- Detalles adicionales de la matriz -->
            </div>
        </div>
    </div>

    <!-- √Årbol de Decisi√≥n -->
    <div class="card" id="treeCard" style="display: none;">
        <div class="card-header">
            <h2>üå≥ √Årbol de Decisi√≥n</h2>
        </div>
        <div class="card-body">
            <div class="tree-controls">
                <button id="expandTree" class="btn btn-info">
                    <i>üîç</i> Expandir Vista
                </button>
                <button id="collapseTree" class="btn btn-info">
                    <i>üîí</i> Vista Normal
                </button>
                <button id="zoomIn" class="btn btn-secondary">
                    <i>‚ûï</i> Zoom In
                </button>
                <button id="zoomOut" class="btn btn-secondary">
                    <i>‚ûñ</i> Zoom Out
                </button>
                <button id="resetView" class="btn btn-secondary">
                    <i>üéØ</i> Centrar
                </button>
                <button id="downloadTree" class="btn btn-success">
                    <i>üíæ</i> Descargar SVG
                </button>
            </div>
            
            <div class="tree-container" id="treeContainer">
                <div id="treeVisualization" class="tree-visualization"></div>
            </div>
            
            <div class="tree-text-container" style="display: none;">
                <h4>Representaci√≥n Textual del √Årbol (Formato J48)</h4>
                <div id="treeTextOutput" class="tree-text"></div>
            </div>
        </div>
    </div>

    <!-- An√°lisis de Caracter√≠sticas -->
    <div class="card" id="featuresCard" style="display: none;">
        <div class="card-header">
            <h2>üî¨ An√°lisis de Caracter√≠sticas</h2>
        </div>
        <div class="card-body">
            <div class="features-analysis">
                <div class="feature-importance">
                    <h3>Importancia de Caracter√≠sticas</h3>
                    <canvas id="featureImportanceChart" width="400" height="300"></canvas>
                </div>
                
                <div class="feature-stats">
                    <h3>Estad√≠sticas de Caracter√≠sticas</h3>
                    <div id="featureStatsTable" class="table-container">
                        <!-- Tabla de estad√≠sticas -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Comparaci√≥n de Modelos -->
    <div class="card">
        <div class="card-header">
            <h2>‚öñÔ∏è Comparaci√≥n de Modelos</h2>
        </div>
        <div class="card-body">
            <div class="comparison-controls">
                <button id="loadComparison" class="btn btn-primary">
                    <i>üìä</i> Cargar Comparaci√≥n
                </button>
                <button id="exportResults" class="btn btn-success">
                    <i>üì§</i> Exportar Resultados
                </button>
            </div>
            
            <div id="comparisonContainer" class="comparison-container">
                <canvas id="comparisonChart" width="600" height="400"></canvas>
            </div>
        </div>
    </div>
</div>

<style>
.results-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

.header-section {
    text-align: center;
    margin-bottom: 30px;
}

.header-section h1 {
    color: #2c3e50;
    margin-bottom: 10px;
}

.header-section p {
    color: #7f8c8d;
    font-size: 1.1em;
}

.card {
    background: white;
    border-radius: 10px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    margin-bottom: 25px;
    overflow: hidden;
}

.card-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 20px;
}

.card-header h2 {
    margin: 0;
    font-size: 1.4em;
}

.card-body {
    padding: 25px;
}

.model-selection {
    display: flex;
    gap: 15px;
    align-items: center;
}

.form-select {
    flex: 1;
    padding: 12px;
    border: 2px solid #e0e6ed;
    border-radius: 8px;
    font-size: 14px;
    transition: border-color 0.3s ease;
}

.form-select:focus {
    outline: none;
    border-color: #3498db;
}

.btn {
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    text-decoration: none;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    white-space: nowrap;
}

.btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.btn-primary {
    background: linear-gradient(135deg, #3498db, #2980b9);
    color: white;
}

.btn-secondary {
    background: linear-gradient(135deg, #95a5a6, #7f8c8d);
    color: white;
}

.btn-success {
    background: linear-gradient(135deg, #2ecc71, #27ae60);
    color: white;
}

.btn-info {
    background: linear-gradient(135deg, #17a2b8, #138496);
    color: white;
}

.btn:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.15);
}

.metrics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 20px;
    margin-bottom: 30px;
}

.metric-card {
    background: linear-gradient(135deg, #f8f9fa, #e9ecef);
    border: 1px solid #dee2e6;
    border-radius: 10px;
    padding: 20px;
    text-align: center;
    transition: all 0.3s ease;
}

.metric-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 15px rgba(0,0,0,0.1);
}

.metric-value {
    font-size: 2.5em;
    font-weight: bold;
    color: #2c3e50;
    margin-bottom: 10px;
}

.metric-label {
    font-size: 1.1em;
    color: #7f8c8d;
    font-weight: 600;
}

.metric-description {
    font-size: 0.9em;
    color: #95a5a6;
    margin-top: 5px;
}

.metrics-table-container {
    margin-top: 30px;
}

.table-container {
    overflow-x: auto;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.weka-table {
    width: 100%;
    border-collapse: collapse;
    font-family: 'Courier New', monospace;
    font-size: 14px;
}

.weka-table th,
.weka-table td {
    padding: 12px 15px;
    text-align: left;
    border-bottom: 1px solid #ddd;
}

.weka-table th {
    background: #f8f9fa;
    font-weight: bold;
    color: #2c3e50;
}

.weka-table tr:hover {
    background: #f5f5f5;
}

.chart-container {
    display: flex;
    justify-content: center;
    margin-bottom: 20px;
}

.confusion-details {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 20px;
    margin-top: 20px;
}

.tree-controls {
    display: flex;
    gap: 15px;
    margin-bottom: 20px;
    flex-wrap: wrap;
}

.tree-container {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 20px;
    margin-bottom: 20px;
    overflow: auto;
    max-height: 700px;
}

.tree-svg-container {
    display: flex;
    justify-content: center;
    margin-bottom: 20px;
    overflow: auto;
}

.tree-instructions {
    background: linear-gradient(135deg, #e8f4fd 0%, #ffffff 100%);
    border: 2px solid #3498db;
    border-radius: 8px;
    padding: 12px;
    margin: 15px 0;
    font-size: 14px;
}

.instructions-content {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 15px;
    justify-content: center;
}

.instructions-content strong {
    color: #2c3e50;
    margin-right: 10px;
}

.instructions-content span {
    background: white;
    padding: 4px 8px;
    border-radius: 4px;
    border: 1px solid #bdc3c7;
    font-size: 12px;
    color: #34495e;
}

.tree-legend {
    background: #f8f9fa;
    border: 2px solid #e9ecef;
    border-radius: 8px;
    padding: 15px;
    margin-top: 15px;
    font-size: 14px;
}

.legend-title {
    font-weight: bold;
    color: #2c3e50;
    margin-bottom: 10px;
    font-size: 16px;
}

.legend-items {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-bottom: 10px;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 10px;
}

.legend-color {
    width: 20px;
    height: 20px;
    border: 2px solid #666;
    border-radius: 4px;
}

.legend-color.internal-color {
    background: #fff3e0;
    border-color: #ff9800;
}

.legend-color.leaf-color {
    background: #e8f5e8;
    border-color: #4caf50;
}

.legend-line {
    width: 30px;
    height: 2px;
    background: #666;
    border-radius: 1px;
}

.legend-help {
    color: #7f8c8d;
    font-style: italic;
    font-size: 12px;
    border-top: 1px solid #dee2e6;
    padding-top: 8px;
}

.node-details-popup {
    position: absolute;
    background: white;
    border: 2px solid #3498db;
    border-radius: 8px;
    padding: 0;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    z-index: 1000;
    display: none;
    max-width: 300px;
}

.popup-content {
    padding: 15px;
    position: relative;
    font-size: 14px;
    line-height: 1.5;
}

.popup-close {
    position: absolute;
    top: 5px;
    right: 8px;
    background: none;
    border: none;
    font-size: 16px;
    font-weight: bold;
    color: #7f8c8d;
    cursor: pointer;
    padding: 0;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.popup-close:hover {
    color: #e74c3c;
}

.no-tree-message {
    text-align: center;
    color: #7f8c8d;
    font-style: italic;
    padding: 40px;
    background: #f8f9fa;
    border: 2px dashed #dee2e6;
    border-radius: 8px;
}

.tree-text-container {
    margin-top: 20px;
}

.tree-text {
    background: #2c3e50;
    color: #ecf0f1;
    padding: 20px;
    border-radius: 8px;
    font-family: 'Courier New', monospace;
    font-size: 12px;
    line-height: 1.4;
    overflow: auto;
    max-height: 400px;
    white-space: pre-wrap;
}

.features-analysis {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 30px;
}

@media (max-width: 768px) {
    .features-analysis {
        grid-template-columns: 1fr;
    }
}

.feature-importance,
.feature-stats {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 20px;
}

.comparison-controls {
    display: flex;
    gap: 15px;
    margin-bottom: 20px;
    flex-wrap: wrap;
}

.comparison-container {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 20px;
    text-align: center;
}

.loading-spinner {
    display: inline-block;
    width: 20px;
    height: 20px;
    border: 3px solid #f3f3f3;
    border-top: 3px solid #3498db;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.alert {
    padding: 15px;
    margin-bottom: 20px;
    border: 1px solid transparent;
    border-radius: 8px;
}

.alert-success {
    color: #155724;
    background-color: #d4edda;
    border-color: #c3e6cb;
}

.alert-error {
    color: #721c24;
    background-color: #f8d7da;
    border-color: #f5c6cb;
}

.alert-info {
    color: #0c5460;
    background-color: #d1ecf1;
    border-color: #bee5eb;
}

/* Estilo similar a Weka */
.weka-style {
    font-family: 'Courier New', monospace;
    background: #f0f0f0;
    border: 2px solid #999;
    padding: 15px;
    border-radius: 5px;
}

.weka-header {
    background: #e0e0e0;
    padding: 10px;
    border-bottom: 1px solid #999;
    font-weight: bold;
}

.node {
    background: white;
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 8px;
    margin: 2px;
    display: inline-block;
    cursor: pointer;
    transition: all 0.3s ease;
}

.node:hover {
    background: #e3f2fd;
    border-color: #2196f3;
}

.node.leaf {
    background: #e8f5e8;
    border-color: #4caf50;
}

.tree-level-0 { margin-left: 0px; }
.tree-level-1 { margin-left: 20px; }
.tree-level-2 { margin-left: 40px; }
.tree-level-3 { margin-left: 60px; }
.tree-level-4 { margin-left: 80px; }

/* Estilos para √°rbol estilo Weka */
.weka-tree-container {
    font-family: 'Courier New', monospace;
    font-size: 13px;
    line-height: 1.6;
    background: #f8f9fa;
    border: 2px solid #dee2e6;
    border-radius: 8px;
    padding: 20px;
    margin: 10px 0;
    overflow: auto;
    max-height: 800px;
}

.weka-node {
    margin: 5px 0;
    position: relative;
}

.weka-node.internal-node > .node-content {
    font-weight: bold;
    color: #2c3e50;
    background: linear-gradient(90deg, #e8f4fd 0%, #ffffff 100%);
    padding: 4px 8px;
    border-left: 3px solid #3498db;
    margin-bottom: 8px;
    border-radius: 3px;
}

.weka-node.leaf-node > .node-content {
    color: #27ae60;
    background: linear-gradient(90deg, #e8f6f0 0%, #ffffff 100%);
    padding: 4px 8px;
    border-left: 3px solid #27ae60;
    border-radius: 3px;
    font-weight: 600;
}

.feature-name {
    color: #2c3e50;
    font-weight: bold;
}

.class-label {
    color: #27ae60;
    font-weight: bold;
    font-size: 14px;
}

.sample-count {
    color: #7f8c8d;
    font-style: italic;
    font-size: 12px;
}

.confidence {
    color: #e67e22;
    font-weight: bold;
    font-size: 12px;
}

.weka-branches {
    margin-left: 20px;
    border-left: 2px dotted #bdc3c7;
    padding-left: 10px;
}

.weka-branch {
    margin: 8px 0;
    position: relative;
}

.weka-branch::before {
    content: '‚îú‚îÄ';
    position: absolute;
    left: -12px;
    color: #bdc3c7;
    font-weight: bold;
}

.weka-branch:last-child::before {
    content: '‚îî‚îÄ';
}

.branch-label {
    color: #8e44ad;
    font-weight: bold;
    background: #f8f9fa;
    padding: 2px 6px;
    border-radius: 3px;
    display: inline-block;
    margin-bottom: 5px;
    border: 1px solid #e9ecef;
    font-size: 12px;
}

.branch-content {
    margin-left: 15px;
}

/* Mejoras para la matriz de confusi√≥n */
.confusion-matrix-container {
    margin: 20px 0;
    display: flex;
    justify-content: center;
}

.confusion-matrix-table {
    border-collapse: collapse;
    font-family: 'Arial', sans-serif;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    border-radius: 8px;
    overflow: hidden;
    background: white;
}

.confusion-matrix-table th {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 12px 15px;
    text-align: center;
    font-weight: bold;
    font-size: 14px;
}

.confusion-matrix-table td {
    padding: 15px;
    text-align: center;
    font-weight: bold;
    font-size: 16px;
    border: 1px solid #e0e6ed;
    position: relative;
    min-width: 80px;
    min-height: 60px;
}

.confusion-matrix-table .row-header {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    color: #2c3e50;
    font-weight: bold;
    writing-mode: vertical-rl;
    text-orientation: mixed;
}

.confusion-matrix-table .correct-prediction {
    background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
    color: #155724;
    box-shadow: inset 0 0 10px rgba(40, 167, 69, 0.2);
}

.confusion-matrix-table .incorrect-prediction {
    background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
    color: #721c24;
    box-shadow: inset 0 0 10px rgba(220, 53, 69, 0.2);
}

.confusion-matrix-table .empty-cell {
    background: #f8f9fa;
    color: #6c757d;
}

.confusion-matrix-table .percentage {
    font-size: 12px;
    color: #6c757d;
    display: block;
    margin-top: 2px;
}

.confusion-details {
    margin-top: 20px;
    background: #f8f9fa;
    border-radius: 8px;
    padding: 20px;
}

.confusion-details h4 {
    color: #2c3e50;
    margin-bottom: 15px;
    border-bottom: 2px solid #3498db;
    padding-bottom: 8px;
}

.metrics-summary {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin-top: 15px;
}

.metric-item {
    background: white;
    padding: 12px;
    border-radius: 6px;
    border-left: 4px solid #3498db;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.metric-item .metric-label {
    font-weight: bold;
    color: #2c3e50;
    font-size: 12px;
    text-transform: uppercase;
}

.metric-item .metric-value {
    font-size: 18px;
    font-weight: bold;
    color: #27ae60;
    margin-top: 4px;
}

/* Estilos para √°rbol J48 aut√©ntico de Weka */
.weka-j48-output {
    font-family: 'Courier New', 'Lucida Console', monospace;
    font-size: 12px;
    line-height: 1.4;
    background: #ffffff;
    color: #000000;
    border: 2px solid #c0c0c0;
    padding: 15px;
    margin: 10px 0;
    overflow: auto;
    max-height: 600px;
    white-space: pre;
    text-align: left;
}

.j48-header {
    font-weight: bold;
    color: #000000;
    margin-bottom: 10px;
    border-bottom: 1px solid #c0c0c0;
    padding-bottom: 5px;
}

.j48-tree-line {
    margin: 0;
    padding: 0;
    line-height: 1.3;
}

.j48-attribute {
    color: #000080;
    font-weight: bold;
}

.j48-operator {
    color: #000000;
    font-weight: normal;
}

.j48-value {
    color: #800080;
    font-weight: normal;
}

.j48-class {
    color: #008000;
    font-weight: bold;
}

.j48-instances {
    color: #808080;
    font-weight: normal;
}

.j48-confidence {
    color: #ff6600;
    font-weight: normal;
}

.j48-statistics {
    color: #000000;
    font-weight: normal;
    margin-top: 10px;
    border-top: 1px solid #c0c0c0;
    padding-top: 10px;
}
</style>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
    const resultsModelSelect = document.getElementById('resultsModelSelect');
    const refreshResultsModels = document.getElementById('refreshResultsModels');
    const metricsCard = document.getElementById('metricsCard');
    const confusionCard = document.getElementById('confusionCard');
    const treeCard = document.getElementById('treeCard');
    const featuresCard = document.getElementById('featuresCard');
    
    let currentResults = null;
    let charts = {};
    
    // Load available models
    function loadResultsModels() {
        fetch('/api/models')
            .then(response => response.json())
            .then(data => {
                resultsModelSelect.innerHTML = '<option value="">Selecciona un modelo para ver resultados...</option>';
                
                if (data.models && data.models.length > 0) {
                    data.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.id || model.model_id;
                        option.textContent = `${model.name || model.algorithm.toUpperCase()}_${model.id || model.model_id} - ${model.algorithm.toUpperCase()} (${(model.accuracy * 100).toFixed(2)}%)`;
                        resultsModelSelect.appendChild(option);
                    });
                    
                    // Auto-select the last trained model if available
                    const selectedModelId = window.localStorage.getItem('selectedModelId') || window.localStorage.getItem('lastTrainedModel');
                    if (selectedModelId) {
                        const option = Array.from(resultsModelSelect.options).find(opt => opt.value === selectedModelId);
                        if (option) {
                            resultsModelSelect.value = selectedModelId;
                            loadModelResults(selectedModelId);
                            // Clear the stored ID after use
                            window.localStorage.removeItem('selectedModelId');
                        }
                    }
                } else {
                    const option = document.createElement('option');
                    option.textContent = 'No hay modelos disponibles';
                    option.disabled = true;
                    resultsModelSelect.appendChild(option);
                }
            })
            .catch(error => {
                console.error('Error loading models:', error);
                showMessage('Error al cargar los modelos', 'error');
            });
    }
    
    // Handle model selection for results
    resultsModelSelect.addEventListener('change', function() {
        if (this.value) {
            loadModelResults(this.value);
        } else {
            hideAllCards();
        }
    });
    
    function hideAllCards() {
        metricsCard.style.display = 'none';
        confusionCard.style.display = 'none';
        treeCard.style.display = 'none';
        featuresCard.style.display = 'none';
    }
    
    function loadModelResults(modelId) {
        showMessage('Cargando resultados...', 'info');
        
        fetch(`/api/models/${modelId}/results`)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.error) {
                    throw new Error(data.error);
                }
                currentResults = data;
                displayResults(data);
                clearMessage();
            })
            .catch(error => {
                console.error('Error loading model results:', error);
                showMessage(`Error al cargar los resultados del modelo: ${error.message}`, 'error');
                hideAllCards();
            });
    }
    
    function displayResults(results) {
        // Show metrics
        displayMetrics(results.metrics);
        metricsCard.style.display = 'block';
        
        // Show confusion matrix
        if (results.confusion_matrix) {
            displayConfusionMatrix(results.confusion_matrix, results.class_names);
            confusionCard.style.display = 'block';
        }
        
        // Show decision tree (only for ID3)
        if (results.algorithm === 'id3' && results.tree_structure) {
            displayDecisionTree(results.tree_structure);
            treeCard.style.display = 'block';
        }
        
        // Show feature analysis
        if (results.feature_importance || results.feature_stats) {
            displayFeatureAnalysis(results);
            featuresCard.style.display = 'block';
        }
    }
    
    function displayMetrics(metrics) {
        const metricsGrid = document.getElementById('metricsGrid');
        
        const metricCards = [
            { key: 'accuracy', label: 'Precisi√≥n', description: 'Porcentaje de predicciones correctas', format: 'percentage' },
            { key: 'precision', label: 'Precisi√≥n', description: 'Precisi√≥n promedio por clase', format: 'percentage' },
            { key: 'recall', label: 'Recall', description: 'Recall promedio por clase', format: 'percentage' },
            { key: 'f1_score', label: 'F1-Score', description: 'Media arm√≥nica de precisi√≥n y recall', format: 'percentage' },
            { key: 'support', label: 'Soporte', description: 'N√∫mero total de muestras', format: 'number' }
        ];
        
        metricsGrid.innerHTML = metricCards.map(metric => {
            const value = metrics[metric.key];
            const displayValue = metric.format === 'percentage' 
                ? `${(value * 100).toFixed(2)}%` 
                : value.toFixed(0);
            
            return `
                <div class="metric-card">
                    <div class="metric-value">${displayValue}</div>
                    <div class="metric-label">${metric.label}</div>
                    <div class="metric-description">${metric.description}</div>
                </div>
            `;
        }).join('');
        
        // Display classification report
        if (metrics.classification_report) {
            displayClassificationReport(metrics.classification_report);
        }
    }
    
    function displayClassificationReport(report) {
        const container = document.getElementById('classificationReport');
        
        const headers = ['Clase', 'Precisi√≥n', 'Recall', 'F1-Score', 'Soporte'];
        
        let tableHTML = `
            <table class="weka-table">
                <thead>
                    <tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr>
                </thead>
                <tbody>
        `;
        
        // Add rows for each class
        Object.entries(report).forEach(([className, metrics]) => {
            if (typeof metrics === 'object' && !['accuracy', 'macro avg', 'weighted avg'].includes(className)) {
                tableHTML += `
                    <tr>
                        <td><strong>${className}</strong></td>
                        <td>${(metrics.precision * 100).toFixed(2)}%</td>
                        <td>${(metrics.recall * 100).toFixed(2)}%</td>
                        <td>${(metrics['f1-score'] * 100).toFixed(2)}%</td>
                        <td>${metrics.support}</td>
                    </tr>
                `;
            }
        });
        
        // Add summary rows
        if (report['macro avg']) {
            tableHTML += `
                <tr style="border-top: 2px solid #333;">
                    <td><strong>Promedio Macro</strong></td>
                    <td>${(report['macro avg'].precision * 100).toFixed(2)}%</td>
                    <td>${(report['macro avg'].recall * 100).toFixed(2)}%</td>
                    <td>${(report['macro avg']['f1-score'] * 100).toFixed(2)}%</td>
                    <td>${report['macro avg'].support}</td>
                </tr>
            `;
        }
        
        if (report['weighted avg']) {
            tableHTML += `
                <tr>
                    <td><strong>Promedio Ponderado</strong></td>
                    <td>${(report['weighted avg'].precision * 100).toFixed(2)}%</td>
                    <td>${(report['weighted avg'].recall * 100).toFixed(2)}%</td>
                    <td>${(report['weighted avg']['f1-score'] * 100).toFixed(2)}%</td>
                    <td>${report['weighted avg'].support}</td>
                </tr>
            `;
        }
        
        tableHTML += '</tbody></table>';
        container.innerHTML = tableHTML;
    }
    
    function displayConfusionMatrix(matrix, classNames) {
        const container = document.getElementById('confusionMatrixTable');
        
        // Calculate total samples and percentages
        const totalSamples = matrix.flat().reduce((sum, val) => sum + val, 0);
        
        // Create table HTML
        let tableHTML = '<table class="confusion-matrix-table">';
        
        // Header row
        tableHTML += '<thead><tr>';
        tableHTML += '<th style="background: #6c757d;">Clasificado como ‚Üí</th>';
        classNames.forEach(className => {
            tableHTML += `<th>${className}</th>`;
        });
        tableHTML += '<th style="background: #6c757d;">Total</th>';
        tableHTML += '</tr></thead>';
        
        // Data rows
        tableHTML += '<tbody>';
        classNames.forEach((actualClass, i) => {
            tableHTML += '<tr>';
            
            // Row header
            tableHTML += `<td class="row-header">${actualClass}</td>`;
            
            // Data cells
            let rowTotal = 0;
            classNames.forEach((predictedClass, j) => {
                const value = matrix[i][j];
                const percentage = ((value / totalSamples) * 100).toFixed(1);
                const isCorrect = i === j;
                const cellClass = value === 0 ? 'empty-cell' : (isCorrect ? 'correct-prediction' : 'incorrect-prediction');
                
                tableHTML += `<td class="${cellClass}">`;
                tableHTML += `<div style="font-size: 18px; font-weight: bold;">${value}</div>`;
                if (value > 0) {
                    tableHTML += `<span class="percentage">(${percentage}%)</span>`;
                }
                tableHTML += '</td>';
                
                rowTotal += value;
            });
            
            // Row total
            tableHTML += `<td style="background: #e9ecef; font-weight: bold; color: #495057;">${rowTotal}</td>`;
            tableHTML += '</tr>';
        });
        
        // Footer row with column totals
        tableHTML += '<tr>';
        tableHTML += '<td style="background: #6c757d; color: white; font-weight: bold;">Total</td>';
        classNames.forEach((_, j) => {
            const colTotal = matrix.reduce((sum, row) => sum + row[j], 0);
            tableHTML += `<td style="background: #e9ecef; font-weight: bold; color: #495057;">${colTotal}</td>`;
        });
        tableHTML += `<td style="background: #6c757d; color: white; font-weight: bold;">${totalSamples}</td>`;
        tableHTML += '</tr>';
        
        tableHTML += '</tbody></table>';
        
        // Add legend
        tableHTML += `
            <div style="margin-top: 15px; display: flex; justify-content: center; gap: 20px; font-size: 14px;">
                <div style="display: flex; align-items: center; gap: 5px;">
                    <div style="width: 20px; height: 20px; background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%); border-radius: 3px;"></div>
                    <span>Predicciones Correctas</span>
                </div>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <div style="width: 20px; height: 20px; background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%); border-radius: 3px;"></div>
                    <span>Predicciones Incorrectas</span>
                </div>
            </div>
        `;
        
        container.innerHTML = tableHTML;
        
        // Display additional confusion matrix details
        displayConfusionDetails(matrix, classNames);
    }
    
    function displayConfusionDetails(matrix, classNames) {
        const container = document.getElementById('confusionDetails');
        
        // Calculate overall metrics
        let totalCorrect = 0;
        let totalSamples = 0;
        let overallPrecision = 0;
        let overallRecall = 0;
        
        for (let i = 0; i < classNames.length; i++) {
            totalCorrect += matrix[i][i];
            totalSamples += matrix[i].reduce((sum, val) => sum + val, 0);
        }
        
        const accuracy = (totalCorrect / totalSamples * 100).toFixed(2);
        
        let detailsHTML = '<h4>üìä An√°lisis Detallado de la Matriz de Confusi√≥n</h4>';
        
        // Overall metrics summary
        detailsHTML += '<div class="metrics-summary">';
        detailsHTML += `
            <div class="metric-item">
                <div class="metric-label">Precisi√≥n Global</div>
                <div class="metric-value">${accuracy}%</div>
            </div>
            <div class="metric-item">
                <div class="metric-label">Total de Muestras</div>
                <div class="metric-value">${totalSamples}</div>
            </div>
            <div class="metric-item">
                <div class="metric-label">Predicciones Correctas</div>
                <div class="metric-value">${totalCorrect}</div>
            </div>
            <div class="metric-item">
                <div class="metric-label">Predicciones Incorrectas</div>
                <div class="metric-value">${totalSamples - totalCorrect}</div>
            </div>
        `;
        detailsHTML += '</div>';
        
        // Per-class detailed metrics
        detailsHTML += '<h5 style="margin-top: 25px; color: #2c3e50;">üìã M√©tricas por Clase</h5>';
        detailsHTML += '<div class="weka-style" style="background: white; border: 1px solid #dee2e6;">';
        
        classNames.forEach((className, i) => {
            const tp = matrix[i][i];
            const fp = matrix.map(row => row[i]).reduce((sum, val, idx) => idx !== i ? sum + val : sum, 0);
            const fn = matrix[i].reduce((sum, val, idx) => idx !== i ? sum + val : sum, 0);
            const tn = matrix.flat().reduce((sum, val) => sum + val, 0) - tp - fp - fn;
            
            const precision = tp / (tp + fp) || 0;
            const recall = tp / (tp + fn) || 0;
            const specificity = tn / (tn + fp) || 0;
            const f1Score = 2 * (precision * recall) / (precision + recall) || 0;
            
            // Color coding based on performance
            const performanceColor = precision > 0.8 ? '#27ae60' : precision > 0.6 ? '#f39c12' : '#e74c3c';
            
            detailsHTML += `
                <div style="margin-bottom: 20px; padding: 15px; border-left: 4px solid ${performanceColor}; background: #f8f9fa;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <strong style="color: #2c3e50; font-size: 16px;">üè∑Ô∏è Clase: ${className}</strong>
                        <span style="background: ${performanceColor}; color: white; padding: 2px 8px; border-radius: 12px; font-size: 12px; font-weight: bold;">
                            ${precision > 0.8 ? 'EXCELENTE' : precision > 0.6 ? 'BUENO' : 'MEJORABLE'}
                        </span>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; font-size: 13px;">
                        <div><strong>VP:</strong> ${tp} <span style="color: #7f8c8d;">(Verdaderos Positivos)</span></div>
                        <div><strong>FP:</strong> ${fp} <span style="color: #7f8c8d;">(Falsos Positivos)</span></div>
                        <div><strong>FN:</strong> ${fn} <span style="color: #7f8c8d;">(Falsos Negativos)</span></div>
                        <div><strong>VN:</strong> ${tn} <span style="color: #7f8c8d;">(Verdaderos Negativos)</span></div>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-top: 10px; font-size: 13px;">
                        <div><strong>Precisi√≥n:</strong> <span style="color: ${performanceColor}; font-weight: bold;">${(precision * 100).toFixed(1)}%</span></div>
                        <div><strong>Recall:</strong> <span style="color: ${performanceColor}; font-weight: bold;">${(recall * 100).toFixed(1)}%</span></div>
                        <div><strong>F1-Score:</strong> <span style="color: ${performanceColor}; font-weight: bold;">${(f1Score * 100).toFixed(1)}%</span></div>
                        <div><strong>Especificidad:</strong> <span style="color: ${performanceColor}; font-weight: bold;">${(specificity * 100).toFixed(1)}%</span></div>
                    </div>
                </div>
            `;
        });
        
        detailsHTML += '</div>';
        
        // Add interpretation guide
        detailsHTML += `
            <div style="margin-top: 20px; padding: 15px; background: #e8f4fd; border-radius: 8px; border-left: 4px solid #3498db;">
                <h6 style="color: #2c3e50; margin-bottom: 10px;">üìö Gu√≠a de Interpretaci√≥n</h6>
                <div style="font-size: 12px; color: #5d6d7e; line-height: 1.5;">
                    <strong>Precisi√≥n:</strong> De todas las predicciones positivas, qu√© porcentaje fue correcto<br>
                    <strong>Recall (Sensibilidad):</strong> De todas las instancias positivas reales, qu√© porcentaje se detect√≥<br>
                    <strong>F1-Score:</strong> Media arm√≥nica entre precisi√≥n y recall<br>
                    <strong>Especificidad:</strong> De todas las instancias negativas reales, qu√© porcentaje se identific√≥ correctamente
                </div>
            </div>
        `;
        
        container.innerHTML = detailsHTML;
    }
    
    function displayDecisionTree(treeStructure) {
        const container = document.getElementById('treeVisualization');
        const textOutput = document.getElementById('treeTextOutput');
        
        // Clear container
        container.innerHTML = '';
        
        // Create visual tree like Weka's tree visualizer
        createVisualTree(treeStructure, container);
        
        // Generate text output for reference
        const j48Output = generateWekaJ48Output(treeStructure);
        if (textOutput) {
            textOutput.innerHTML = `<div class="j48-text-output">${j48Output}</div>`;
        }
        
        // Add tree controls functionality
        setupTreeControls();
    }
    
    function generateWekaJ48Output(treeData) {
        if (!treeData) {
            return "J48 pruned tree\n------------------\n\nNo tree data available\n\nNumber of Leaves  : 0\nSize of the tree : 0";
        }
        
        let output = "J48 pruned tree\n------------------\n\n";
        
        // Generate the tree structure
        output += generateJ48TreeStructure(treeData, "", true);
        
        // Add statistics
        const numLeaves = countLeaves(treeData);
        const treeSize = countNodes(treeData);
        
        output += "\nNumber of Leaves  : " + numLeaves;
        output += "\nSize of the tree : " + treeSize;
        
        return output;
    }
    
    function generateJ48TreeStructure(node, prefix, isRoot) {
        if (!node) return "";
        
        let result = "";
        const isLeaf = !node.children || node.children.length === 0;
        
        if (isLeaf) {
            // Leaf node format: class (instances) or class (instances/misclassified)
            result += node.class || "unknown";
            if (node.samples) {
                if (node.misclassified && node.misclassified > 0) {
                    result += " (" + node.samples + ".0/" + node.misclassified + ".0)";
                } else {
                    result += " (" + node.samples + ".0)";
                }
            }
            result += "\n";
        } else {
            // Internal node - process children
            if (node.children && node.children.length > 0) {
                for (let i = 0; i < node.children.length; i++) {
                    const child = node.children[i];
                    const isLast = i === node.children.length - 1;
                    
                    // Generate the condition line
                    result += prefix;
                    result += node.feature || "attribute";
                    
                    // Add condition
                    if (child.condition) {
                        result += " " + child.condition;
                    } else if (child.value !== undefined) {
                        result += " = " + child.value;
                    } else {
                        result += " = value" + (i + 1);
                    }
                    
                    const childIsLeaf = !child.children || child.children.length === 0;
                    
                    if (childIsLeaf) {
                        result += ": ";
                        result += generateJ48TreeStructure(child, "", false);
                    } else {
                        result += "\n";
                        const newPrefix = prefix + "|   ";
                        result += generateJ48TreeStructure(child, newPrefix, false);
                    }
                }
            }
        }
        
        return result;
    }
    
    function countLeaves(node) {
        if (!node) return 0;
        if (!node.children || node.children.length === 0) return 1;
        
        let count = 0;
        for (let child of node.children) {
            count += countLeaves(child);
        }
        return count;
    }
    
    function countNodes(node) {
        if (!node) return 0;
        
        let count = 1;
        if (node.children) {
            for (let child of node.children) {
                count += countNodes(child);
            }
        }
        return count;
    }
    
    function createVisualTree(treeData, container) {
        if (!treeData) {
            container.innerHTML = '<div class="no-tree-message">No hay estructura de √°rbol disponible</div>';
            return;
        }
        
        // Create SVG container with pan and zoom capabilities
        const svgContainer = document.createElement('div');
        svgContainer.className = 'tree-svg-container';
        svgContainer.style.position = 'relative';
        svgContainer.style.overflow = 'hidden';
        svgContainer.style.cursor = 'grab';
        
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '800');  // Increased height for deeper trees
        svg.setAttribute('viewBox', '0 0 1400 800');  // Wider viewBox for complex trees
        svg.style.background = '#ffffff';
        svg.style.border = '2px solid #c0c0c0';
        svg.style.borderRadius = '8px';
        
        // Add zoom and pan functionality
        let currentZoom = 1;
        let currentPanX = 0;
        let currentPanY = 0;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        // Create a group for transformations
        const transformGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        transformGroup.setAttribute('class', 'transform-group');
        svg.appendChild(transformGroup);
        
        // Mouse event handlers
        svg.addEventListener('mousedown', function(e) {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            svg.style.cursor = 'grabbing';
            e.preventDefault();
        });
        
        svg.addEventListener('mousemove', function(e) {
            if (isDragging) {
                const deltaX = (e.clientX - lastMouseX) / currentZoom;
                const deltaY = (e.clientY - lastMouseY) / currentZoom;
                currentPanX += deltaX;
                currentPanY += deltaY;
                
                updateTransform();
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                e.preventDefault();
            }
        });
        
        svg.addEventListener('mouseup', function(e) {
            isDragging = false;
            svg.style.cursor = 'grab';
        });
        
        svg.addEventListener('mouseleave', function(e) {
            isDragging = false;
            svg.style.cursor = 'grab';
        });
        
        // Wheel zoom
        svg.addEventListener('wheel', function(e) {
            e.preventDefault();
            const rect = svg.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.min(Math.max(currentZoom * zoomFactor, 0.1), 5);
            
            if (newZoom !== currentZoom) {
                // Zoom towards mouse position
                const scale = newZoom / currentZoom;
                currentPanX = mouseX - scale * (mouseX - currentPanX);
                currentPanY = mouseY - scale * (mouseY - currentPanY);
                currentZoom = newZoom;
                
                updateTransform();
            }
        });
        
        function updateTransform() {
            transformGroup.setAttribute('transform', 
                `translate(${currentPanX}, ${currentPanY}) scale(${currentZoom})`);
        }
        
        // Store transform functions for external access
        svg._zoomIn = function() {
            currentZoom = Math.min(currentZoom * 1.2, 5);
            updateTransform();
        };
        
        svg._zoomOut = function() {
            currentZoom = Math.max(currentZoom / 1.2, 0.1);
            updateTransform();
        };
        
        svg._resetView = function() {
            currentZoom = 1;
            currentPanX = 0;
            currentPanY = 0;
            updateTransform();
        };
        
        // Add styles for the tree
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        const style = document.createElementNS('http://www.w3.org/2000/svg', 'style');
        style.textContent = `
            .tree-node { cursor: pointer; }
            .tree-node:hover .node-rect { fill: #e3f2fd; stroke: #2196f3; }
            .tree-text { font-family: 'Arial', sans-serif; font-size: 12px; text-anchor: middle; }
            .tree-line { stroke: #666; stroke-width: 2; }
            .leaf-node .node-rect { fill: #e8f5e8; stroke: #4caf50; }
            .internal-node .node-rect { fill: #fff3e0; stroke: #ff9800; }
            .branch-text { font-family: 'Arial', sans-serif; font-size: 10px; fill: #666; text-anchor: middle; }
        `;
        defs.appendChild(style);
        transformGroup.appendChild(defs);
        
        // Calculate tree layout
        const layout = calculateTreeLayout(treeData);
        
        // Draw connections first (so they appear behind nodes)
        drawConnections(transformGroup, layout);
        
        // Draw nodes
        drawNodes(transformGroup, layout);
        
        svgContainer.appendChild(svg);
        container.appendChild(svgContainer);
        
        // Add navigation instructions
        const instructions = document.createElement('div');
        instructions.className = 'tree-instructions';
        instructions.innerHTML = `
            <div class="instructions-content">
                <strong>üéÆ Navegaci√≥n del √Årbol:</strong>
                <span>‚Ä¢ Arrastra para mover</span>
                <span>‚Ä¢ Rueda del mouse para zoom</span>
                <span>‚Ä¢ Clic en nodos para detalles</span>
            </div>
        `;
        container.appendChild(instructions);
        
        // Add legend
        const legend = createTreeLegend();
        container.appendChild(legend);
        
        // Store SVG reference for controls
        container._treeSvg = svg;
    }
    
    function calculateTreeLayout(node, level = 0, position = 600, parentX = null, siblingIndex = 0, totalSiblings = 1) {
        const layout = {
            node: node,
            level: level,
            x: position,
            y: level * 120 + 60,  // Increased vertical spacing for complex trees
            children: [],
            parentX: parentX
        };
        
        if (node.children && node.children.length > 0) {
            const baseSpacing = Math.max(200, 1200 / Math.pow(2, level)); // Dynamic spacing based on level
            const totalWidth = baseSpacing * (node.children.length - 1);
            const startX = position - totalWidth / 2;
            
            node.children.forEach((child, index) => {
                const childX = node.children.length === 1 ? position : startX + (index * baseSpacing);
                const childLayout = calculateTreeLayout(child, level + 1, childX, position, index, node.children.length);
                layout.children.push(childLayout);
            });
        }
        
        return layout;
    }
    
    function drawConnections(svgGroup, layout) {
        if (layout.children.length > 0) {
            layout.children.forEach((child, index) => {
                // Draw line from parent to child
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', layout.x);
                line.setAttribute('y1', layout.y + 30);
                line.setAttribute('x2', child.x);
                line.setAttribute('y2', child.y - 10);
                line.setAttribute('class', 'tree-line');
                svgGroup.appendChild(line);
                
                // Add branch label
                if (child.node.condition || child.node.value !== undefined) {
                    const midX = (layout.x + child.x) / 2;
                    const midY = (layout.y + child.y) / 2;
                    
                    let labelText = '';
                    if (child.node.condition) {
                        labelText = child.node.condition;
                    } else if (child.node.value !== undefined) {
                        labelText = `= ${child.node.value}`;
                    }
                    
                    // Add background rectangle for better readability
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', midX - (labelText.length * 3) - 2);
                    rect.setAttribute('y', midY - 8);
                    rect.setAttribute('width', (labelText.length * 6) + 4);
                    rect.setAttribute('height', 14);
                    rect.setAttribute('fill', 'white');
                    rect.setAttribute('stroke', '#ddd');
                    rect.setAttribute('rx', '3');
                    svgGroup.appendChild(rect);
                    
                    const branchText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    branchText.setAttribute('x', midX);
                    branchText.setAttribute('y', midY);
                    branchText.setAttribute('class', 'branch-text');
                    branchText.textContent = labelText;
                    svgGroup.appendChild(branchText);
                }
                
                // Recursively draw child connections
                drawConnections(svgGroup, child);
            });
        }
    }
    
    function drawNodes(svgGroup, layout) {
        const isLeaf = !layout.node.children || layout.node.children.length === 0;
        
        // Create node group
        const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        nodeGroup.setAttribute('class', `tree-node ${isLeaf ? 'leaf-node' : 'internal-node'}`);
        
        // Node rectangle
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('x', layout.x - 60);
        rect.setAttribute('y', layout.y - 15);
        rect.setAttribute('width', '120');
        rect.setAttribute('height', '30');
        rect.setAttribute('rx', '5');
        rect.setAttribute('class', 'node-rect');
        nodeGroup.appendChild(rect);
        
        // Node text
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', layout.x);
        text.setAttribute('y', layout.y + 4);
        text.setAttribute('class', 'tree-text');
        
        if (isLeaf) {
            // Leaf node: show class and statistics
            let leafText = layout.node.class || 'unknown';
            text.textContent = leafText;
            
            // Add sample count and misclassification info
            if (layout.node.samples) {
                const statsText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                statsText.setAttribute('x', layout.x);
                statsText.setAttribute('y', layout.y + 16);
                statsText.setAttribute('class', 'tree-text');
                statsText.setAttribute('font-size', '10');
                statsText.setAttribute('fill', '#666');
                
                let statsContent = `(${layout.node.samples}.0`;
                if (layout.node.misclassified && layout.node.misclassified > 0) {
                    statsContent += `/${layout.node.misclassified}.0`;
                }
                statsContent += ')';
                
                statsText.textContent = statsContent;
                nodeGroup.appendChild(statsText);
            }
        } else {
            // Internal node: show feature name
            text.textContent = layout.node.feature || 'attribute';
        }
        
        nodeGroup.appendChild(text);
        svgGroup.appendChild(nodeGroup);
        
        // Add click handler for node details
        nodeGroup.addEventListener('click', function(e) {
            e.stopPropagation(); // Prevent triggering pan
            showNodeDetails(layout.node, isLeaf);
        });
        
        // Recursively draw child nodes
        layout.children.forEach(child => {
            drawNodes(svgGroup, child);
        });
    }
    
    function createTreeLegend() {
        const legend = document.createElement('div');
        legend.className = 'tree-legend';
        legend.innerHTML = `
            <div class="legend-title">üóÇÔ∏è Leyenda del √Årbol</div>
            <div class="legend-items">
                <div class="legend-item">
                    <div class="legend-color internal-color"></div>
                    <span>Nodos Internos (Atributos de decisi√≥n)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color leaf-color"></div>
                    <span>Nodos Hoja (Clasificaciones finales)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line"></div>
                    <span>Ramas de decisi√≥n con condiciones</span>
                </div>
            </div>
            <div class="legend-help">
                üí° <strong>Tip:</strong> Haz clic en cualquier nodo para ver detalles adicionales
            </div>
        `;
        return legend;
    }
    
    function showNodeDetails(node, isLeaf) {
        let details = '';
        
        if (isLeaf) {
            details = `
                <strong>üè∑Ô∏è Nodo Hoja</strong><br>
                <strong>Clase:</strong> ${node.class || 'unknown'}<br>
                ${node.samples ? `<strong>Muestras:</strong> ${node.samples}<br>` : ''}
                ${node.misclassified ? `<strong>Mal clasificadas:</strong> ${node.misclassified}<br>` : ''}
                ${node.confidence ? `<strong>Confianza:</strong> ${(node.confidence * 100).toFixed(2)}%<br>` : ''}
            `;
            
            if (node.samples && node.misclassified) {
                const accuracy = ((node.samples - node.misclassified) / node.samples * 100).toFixed(1);
                details += `<strong>Precisi√≥n del nodo:</strong> ${accuracy}%<br>`;
            }
        } else {
            details = `
                <strong>üîç Nodo Interno</strong><br>
                <strong>Atributo:</strong> ${node.feature || 'unknown'}<br>
                <strong>Ramas:</strong> ${node.children ? node.children.length : 0}<br>
                ${node.samples ? `<strong>Muestras:</strong> ${node.samples}<br>` : ''}
            `;
            
            if (node.children) {
                details += '<strong>Condiciones:</strong><br>';
                node.children.forEach((child, index) => {
                    const condition = child.condition || `= ${child.value}`;
                    details += `&nbsp;&nbsp;‚Ä¢ ${condition}<br>`;
                });
            }
        }
        
        // Create or update details popup
        let popup = document.querySelector('.node-details-popup');
        if (!popup) {
            popup = document.createElement('div');
            popup.className = 'node-details-popup';
            document.body.appendChild(popup);
        }
        
        popup.innerHTML = `
            <div class="popup-content">
                <button class="popup-close" onclick="this.parentElement.parentElement.style.display='none'">‚úï</button>
                ${details}
            </div>
        `;
        popup.style.display = 'block';
        
        // Position popup near cursor
        const rect = event.target.getBoundingClientRect();
        popup.style.left = (rect.left + window.scrollX + 20) + 'px';
        popup.style.top = (rect.top + window.scrollY - 20) + 'px';
    }
    
    function countLeaves(node) {
        if (!node) return 0;
        if (!node.children || node.children.length === 0) return 1;
        return node.children.reduce((count, child) => count + countLeaves(child), 0);
    }
    
    function countNodes(node) {
        if (!node) return 0;
        let count = 1;
        if (node.children) {
            count += node.children.reduce((total, child) => total + countNodes(child), 0);
        }
        return count;
    }
    
    function setupTreeControls() {
        const expandBtn = document.getElementById('expandTree');
        const collapseBtn = document.getElementById('collapseTree');
        const zoomInBtn = document.getElementById('zoomIn');
        const zoomOutBtn = document.getElementById('zoomOut');
        const resetViewBtn = document.getElementById('resetView');
        const downloadBtn = document.getElementById('downloadTree');
        
        if (expandBtn) {
            expandBtn.addEventListener('click', function() {
                const container = document.getElementById('treeVisualization');
                if (container) {
                    const svg = container._treeSvg;
                    if (svg) {
                        svg.style.height = '1000px';
                        svg.setAttribute('height', '1000');
                        svg.setAttribute('viewBox', '0 0 1600 1000');
                        showMessage('Vista del √°rbol expandida', 'success');
                    }
                }
            });
        }
        
        if (collapseBtn) {
            collapseBtn.addEventListener('click', function() {
                const container = document.getElementById('treeVisualization');
                if (container) {
                    const svg = container._treeSvg;
                    if (svg) {
                        svg.style.height = '800px';
                        svg.setAttribute('height', '800');
                        svg.setAttribute('viewBox', '0 0 1400 800');
                        showMessage('Vista del √°rbol normal', 'info');
                    }
                }
            });
        }
        
        if (zoomInBtn) {
            zoomInBtn.addEventListener('click', function() {
                const container = document.getElementById('treeVisualization');
                if (container && container._treeSvg && container._treeSvg._zoomIn) {
                    container._treeSvg._zoomIn();
                    showMessage('Zoom aumentado', 'info');
                }
            });
        }
        
        if (zoomOutBtn) {
            zoomOutBtn.addEventListener('click', function() {
                const container = document.getElementById('treeVisualization');
                if (container && container._treeSvg && container._treeSvg._zoomOut) {
                    container._treeSvg._zoomOut();
                    showMessage('Zoom reducido', 'info');
                }
            });
        }
        
        if (resetViewBtn) {
            resetViewBtn.addEventListener('click', function() {
                const container = document.getElementById('treeVisualization');
                if (container && container._treeSvg && container._treeSvg._resetView) {
                    container._treeSvg._resetView();
                    showMessage('Vista centrada', 'success');
                }
            });
        }
        
        if (downloadBtn) {
            downloadBtn.addEventListener('click', function() {
                downloadTreeAsSVG();
            });
        }
    }
    
    function downloadTreeAsSVG() {
        const container = document.getElementById('treeVisualization');
        const svg = container.querySelector('svg');
        
        if (!svg) {
            showMessage('Error: No se pudo encontrar el √°rbol para descargar', 'error');
            return;
        }
        
        try {
            // Clone SVG and make it standalone
            const svgClone = svg.cloneNode(true);
            svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            
            // Create blob and download
            const svgData = new XMLSerializer().serializeToString(svgClone);
            const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const link = document.createElement('a');
            link.download = 'arbol_decision_visual.svg';
            link.href = URL.createObjectURL(blob);
            link.click();
            
            // Clean up
            URL.revokeObjectURL(link.href);
            
            showMessage('√Årbol descargado como SVG', 'success');
        } catch (error) {
            console.error('Error downloading tree:', error);
            showMessage('Error al descargar el √°rbol', 'error');
        }
    }
    
    function displayFeatureAnalysis(results) {
        if (results.feature_importance) {
            displayFeatureImportance(results.feature_importance);
        }
        
        if (results.feature_stats) {
            displayFeatureStats(results.feature_stats);
        }
    }
    
    function displayFeatureImportance(importance) {
        const canvas = document.getElementById('featureImportanceChart');
        const ctx = canvas.getContext('2d');
        
        if (charts.featureImportance) {
            charts.featureImportance.destroy();
        }
        
        const features = Object.keys(importance);
        const values = Object.values(importance);
        
        charts.featureImportance = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: features,
                datasets: [{
                    label: 'Importancia',
                    data: values,
                    backgroundColor: 'rgba(54, 162, 235, 0.8)',
                    borderColor: 'rgba(54, 162, 235, 1)',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Importancia'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Caracter√≠sticas'
                        }
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Importancia de Caracter√≠sticas'
                    }
                }
            }
        });
    }
    
    function displayFeatureStats(stats) {
        const container = document.getElementById('featureStatsTable');
        
        let tableHTML = `
            <table class="weka-table">
                <thead>
                    <tr>
                        <th>Caracter√≠stica</th>
                        <th>Media</th>
                        <th>Std Dev</th>
                        <th>M√≠n</th>
                        <th>M√°x</th>
                        <th>Valores √önicos</th>
                    </tr>
                </thead>
                <tbody>
        `;
        
        Object.entries(stats).forEach(([feature, stat]) => {
            tableHTML += `
                <tr>
                    <td><strong>${feature}</strong></td>
                    <td>${stat.mean ? stat.mean.toFixed(3) : 'N/A'}</td>
                    <td>${stat.std ? stat.std.toFixed(3) : 'N/A'}</td>
                    <td>${stat.min !== undefined ? stat.min : 'N/A'}</td>
                    <td>${stat.max !== undefined ? stat.max : 'N/A'}</td>
                    <td>${stat.unique_values || 'N/A'}</td>
                </tr>
            `;
        });
        
        tableHTML += '</tbody></table>';
        container.innerHTML = tableHTML;
    }
    
    // Comparison functionality
    document.getElementById('loadComparison').addEventListener('click', function() {
        loadModelComparison();
    });
    
    function loadModelComparison() {
        fetch('/api/models/comparison')
            .then(response => response.json())
            .then(data => {
                displayModelComparison(data);
            })
            .catch(error => {
                console.error('Error loading model comparison:', error);
                showMessage('Error al cargar la comparaci√≥n de modelos', 'error');
            });
    }
    
    function displayModelComparison(comparisonData) {
        const canvas = document.getElementById('comparisonChart');
        const ctx = canvas.getContext('2d');
        
        if (charts.comparison) {
            charts.comparison.destroy();
        }
        
        const models = comparisonData.models || [];
        const metrics = ['accuracy', 'precision', 'recall', 'f1_score'];
        
        const datasets = metrics.map((metric, index) => ({
            label: metric.charAt(0).toUpperCase() + metric.slice(1),
            data: models.map(model => model.metrics[metric] * 100),
            backgroundColor: `rgba(${54 + index * 50}, ${162 - index * 20}, ${235 - index * 30}, 0.8)`,
            borderColor: `rgba(${54 + index * 50}, ${162 - index * 20}, ${235 - index * 30}, 1)`,
            borderWidth: 1
        }));
        
        charts.comparison = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: models.map(model => `${model.name} (${model.algorithm.toUpperCase()})`),
                datasets: datasets
            },
            options: {
                responsive: true,
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 100,
                        title: {
                            display: true,
                            text: 'Porcentaje (%)'
                        }
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Comparaci√≥n de Modelos'
                    }
                }
            }
        });
    }
    
    // Export functionality
    document.getElementById('exportResults').addEventListener('click', function() {
        if (currentResults) {
            exportResults(currentResults);
        } else {
            showMessage('No hay resultados para exportar', 'warning');
        }
    });
    
    function exportResults(results) {
        const exportData = {
            model_info: {
                algorithm: results.algorithm,
                accuracy: results.metrics.accuracy,
                created_at: new Date().toISOString()
            },
            metrics: results.metrics,
            confusion_matrix: results.confusion_matrix,
            class_names: results.class_names
        };
        
        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `model_results_${results.algorithm}_${new Date().toISOString().slice(0, 10)}.json`;
        a.click();
        window.URL.revokeObjectURL(url);
    }
    
    function downloadTreeAsImage() {
        const treeContainer = document.getElementById('treeVisualization');
        
        // Use html2canvas library if available, otherwise show message
        if (typeof html2canvas !== 'undefined') {
            html2canvas(treeContainer).then(canvas => {
                const link = document.createElement('a');
                link.download = 'decision_tree.png';
                link.href = canvas.toDataURL();
                link.click();
            });
        } else {
            showMessage('Funcionalidad de descarga de imagen no disponible', 'warning');
        }
    }
    
    function showMessage(message, type = 'info') {
        let messageDiv = document.querySelector('.message-display');
        if (!messageDiv) {
            messageDiv = document.createElement('div');
            messageDiv.className = 'message-display';
            document.querySelector('.results-container').insertBefore(messageDiv, document.querySelector('.results-container').firstChild);
        }
        
        messageDiv.innerHTML = `
            <div class="alert alert-${type}">
                ${message}
            </div>
        `;
    }
    
    function clearMessage() {
        const messageDiv = document.querySelector('.message-display');
        if (messageDiv) {
            messageDiv.innerHTML = '';
        }
    }
    
    // Event listeners
    refreshResultsModels.addEventListener('click', loadResultsModels);
    
    // Initialize
    loadResultsModels();
});
</script>
{% endblock %}
